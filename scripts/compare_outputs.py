"""Utility helpers to compare DSSAT Fortran output with the Python model."""

import argparse
import os
import pandas as pd


def read_fortran_output(path: str) -> pd.DataFrame:
    """Return a :class:`pandas.DataFrame` from a DSSAT output file.

    Parameters
    ----------
    path : str
        Location of a ``summary.csv`` file, ``PlantGro.OUT`` file or a
        directory containing either of those files generated by the
        Fortran version of DSSAT.

    Returns
    -------
    pandas.DataFrame
        Parsed contents of the DSSAT output table.
    """

    # If a directory is provided we attempt to locate the expected output
    # files within it. ``summary.csv`` is preferred as it already has comma
    # separated formatting while ``PlantGro.OUT`` is in fixed width format.
    if os.path.isdir(path):
        csv_path = os.path.join(path, "summary.csv")
        if os.path.exists(csv_path):
            return pd.read_csv(csv_path)

        # Fall back to the fixed width ``PlantGro.OUT`` file
        pg_path = os.path.join(path, "PlantGro.OUT")
        if os.path.exists(pg_path):
            return pd.read_fwf(pg_path, skiprows=4)

        raise FileNotFoundError("No DSSAT output found in directory")

    # If ``path`` points directly to a CSV use :func:`pandas.read_csv`
    if path.lower().endswith(".csv"):
        return pd.read_csv(path)

    # Otherwise treat it as a fixed width ``PlantGro.OUT`` file
    return pd.read_fwf(path, skiprows=4)


def read_python_output(path: str) -> pd.DataFrame:
    """Load output produced by the Python implementation.

    Parameters
    ----------
    path : str
        Location of the CSV file written by the Python model.

    Returns
    -------
    pandas.DataFrame
        Parsed contents of the file.
    """

    # Python output is always stored as comma separated text
    return pd.read_csv(path)


def extract_yield(df: pd.DataFrame):
    """Extract the final yield value from an output table.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing columns from either the Python or Fortran
        model output.

    Returns
    -------
    float or None
        The last recorded value from one of several known yield related
        columns. ``None`` is returned if none of the expected columns are
        present.
    """

    # Names used by different DSSAT versions for the yield column
    yield_cols = [
        "fruit_biomass",
        "YIELD",
        "TOTYLD",
        "HWAM",
        "CWAM",
        "harvest_yield",
    ]

    # Loop through possible column names and return the final value of the
    # first match. ``iloc[-1]`` is used because yield typically accumulates
    # over time and the last row corresponds to harvest.
    for col in yield_cols:
        if col in df.columns:
            return float(df[col].iloc[-1])
    return None


def extract_stages(df: pd.DataFrame):
    """Map phenological stages to the day after planting that they occur.

    Parameters
    ----------
    df : pandas.DataFrame
        Output table which must contain a ``stage`` column and a day count
        column such as ``dap`` (days after planting) or ``das`` (days after
        sowing).

    Returns
    -------
    dict
        Dictionary of stage name to the first day when that stage is
        recorded in the table. If no stage information is available an empty
        dictionary is returned.
    """

    # Ensure the required ``stage`` column exists
    if "stage" not in df.columns:
        return {}

    # Determine which column contains the days after planting information.
    # The outputs may use different capitalisation depending on source.
    if "dap" in df.columns:
        day_col = "dap"
    elif "DAP" in df.columns:
        day_col = "DAP"
    elif "das" in df.columns:
        day_col = "das"
    else:
        return {}

    stages = {}
    # ``unique`` provides the list of stages encountered; for each one we
    # take the first row index and record the day value.
    for stage in df["stage"].unique():
        idx = df[df["stage"] == stage].index[0]
        stages[stage] = int(df.loc[idx, day_col])

    return stages


def compare_metrics(fort_df: pd.DataFrame, py_df: pd.DataFrame) -> str:
    """Compare key metrics from two DSSAT output tables.

    Parameters
    ----------
    fort_df : pandas.DataFrame
        Data read from the Fortran model output.
    py_df : pandas.DataFrame
        Data produced by the Python implementation.

    Returns
    -------
    str
        Human readable report summarising yield and phenology differences.
    """

    report_lines = []

    # --- Yield comparison -------------------------------------------------
    f_yield = extract_yield(fort_df)
    p_yield = extract_yield(py_df)

    if f_yield is not None and p_yield is not None:
        # Both outputs have a yield value, compute the difference
        diff = p_yield - f_yield
        report_lines.append(
            f"Yield difference: Python={p_yield:.2f}, Fortran={f_yield:.2f}, diff={diff:.2f}"
        )
    elif f_yield is not None or p_yield is not None:
        # Only one of the outputs has yield information
        report_lines.append("Yield data missing in one of the outputs")

    # --- Phenological stage comparison -----------------------------------
    f_stages = extract_stages(fort_df)
    p_stages = extract_stages(py_df)

    common_stages = set(f_stages) & set(p_stages)
    for stage in sorted(common_stages):
        diff = p_stages[stage] - f_stages[stage]
        report_lines.append(
            f"Stage {stage}: Python DAP={p_stages[stage]}, Fortran DAP={f_stages[stage]}, diff={diff}"
        )

    missing = set(f_stages) ^ set(p_stages)
    for stage in sorted(missing):
        src = "Python" if stage in p_stages else "Fortran"
        report_lines.append(f"Stage {stage} only present in {src} output")

    # Combine all messages using new lines
    return "\n".join(report_lines)


def main():
    """Entry point for the command line interface."""

    # Set up an argument parser for the two required file paths
    parser = argparse.ArgumentParser(
        description="Compare DSSAT and Python outputs",
    )

    # Positional argument: Fortran output (summary.csv or PlantGro.OUT)
    parser.add_argument(
        "fortran_output",
        help="Path to summary.csv or PlantGro.OUT from DSSAT",
    )

    # Positional argument: CSV output from the Python model
    parser.add_argument(
        "python_output", help="CSV file produced by Python model",
    )

    # Parse command line arguments into ``args``
    args = parser.parse_args()

    # Read the Fortran output table
    fort_df = read_fortran_output(args.fortran_output)

    # Read the Python output table
    py_df = read_python_output(args.python_output)

    # Compare metrics and obtain a summary string
    summary = compare_metrics(fort_df, py_df)

    # Output the summary to the terminal
    print("Summary report:\n" + summary)

if __name__ == "__main__":
    main()
